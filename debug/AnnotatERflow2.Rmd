---
title: "AnnotatER workflow"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("ODER")
library("dasper")
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r get_opt_ers}
url <- recount::download_study(
    project = "SRP012682",
    type = "samples",
     download = FALSE
 ) # .file_cache is an internal function to download a bigwig file from a link
 # if the file has been downloaded recently, it will be retrieved from a cache

 bw_path <- ODER:::.file_cache(url[1])
 gtf_url <- paste0(
    "http://ftp.ensembl.org/pub/release-103/gtf/",
     "homo_sapiens/Homo_sapiens.GRCh38.103.chr.gtf.gz"
 )
 gtf_path <- ODER:::.file_cache(gtf_url)
 
 gtex_metadata <- recount::all_metadata("gtex")

gtex_metadata <- gtex_metadata %>%
    as.data.frame() %>%
    dplyr::filter(project == "SRP012682")
 
 opt_ers <- ODER(
     bw_paths = bw_path, auc_raw = gtex_metadata[["auc"]][1],
     auc_target = 40e6 * 100, chrs = c(1),
     genome = "hg38", mccs = c(5, 10), mrgs = c(10, 20),
     gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE,
     exons_no_overlap = NULL, bw_chr = "chr"
 )
```


```{r annotate_junctions, echo=FALSE}
load(file="/data/recount/GTEx_SRP012682/gtex_split_read_table_annotated_rda/lung_split_read_table_annotated.rda")

lung_junc <- gtex_split_read_table_annotated_only_junc_coverage

lungrange <-  GenomicRanges::makeGRangesFromDataFrame(lung_junc)
annotated_junctions <- dasper::junction_annot(junctions = lungrange, ref = gtf_path)
GenomeInfoDb::seqlevelsStyle(annotated_junctions) <- "UCSC" #to match opt_ers
```


```{r overlapping_ERs, include=FALSE}

hits <- GenomicRanges::findOverlaps(opt_ers[["opt_ers"]],
                                    annotated_junctions)

ann_junc_hits <- annotated_junctions[S4Vectors::subjectHits(hits)]

ann_junc_hits$er_index <- S4Vectors::queryHits(hits)

gene_id_list <- mcols(ann_junc_hits)[["gene_id_junction"]] %>% 
    S4Vectors::split(f = ann_junc_hits$er_index)

gene_id_list <- lapply(gene_id_list,function(x) return(unique(unlist(x))))

ann_junc_hits <- ann_junc_hits %>%
    S4Vectors::split(f = ann_junc_hits$er_index)
    
opt_er_gr <- opt_ers[["opt_ers"]]


```


```{r grangelist_test, include=FALSE}
#test_ajh <- ann_junc_hits
# ajh.names <- c(as.character(1:length(opt_er_gr)))
# list_ajh <- vector("list", length(ajh.names))
# names(list_ajh) <- ajh.names

er_indices <- unique(S4Vectors::queryHits(hits))

miss_ers <- numeric(0)
for (i in 1:length(opt_er_gr)){
    if (!(i %in% er_indices)){
        miss_ers <- c(miss_ers,i)
    }
}

empty_grl <- GenomicRanges::GRangesList(lapply(miss_ers,
    function(x)return(GenomicRanges::GRanges(
       # "nochr:0",er_index=x
        )))
             
                                 )
names(empty_grl) <- miss_ers

combi_ajh <- suppressWarnings(c(ann_junc_hits,empty_grl))
sorted_combi_ajh <- combi_ajh[order(as.integer(names(combi_ajh)))]

empty_gil <- vector("list", length = length(miss_ers))
names(empty_gil) <- miss_ers

combi_gil <- c(gene_id_list,empty_gil)
sorted_combi_gil <- combi_gil[order(as.integer(names(combi_gil)))]
sorted_combi_gil <- sorted_combi_gil %>% IRanges::CharacterList()
 

mcols(opt_er_gr)$grl <- sorted_combi_ajh
mcols(opt_er_gr)$genes <- sorted_combi_gil


#gene_id_list <- lapply(sorted_combi_ajh,gene_id_extract)
```
Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
