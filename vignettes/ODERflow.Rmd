---
title: "ODER workflow"
author: 
  - name: Emmanuel Olagbaju
    affiliation:
    - UCL
    email: e.olagbaju@ucl.ac.uk
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('ODER')`"
vignette: >
  %\VignetteIndexEntry{Introduction to ODER}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
```


```{r vignetteSetup, echo=FALSE, message=FALSE, warning = FALSE}
## Track time spent on making the vignette
startTime <- Sys.time()

## Bib setup
library("RefManageR")

# ## Write bibliography information
# bib <- c(
#     R = citation(),
#     BiocStyle = citation("BiocStyle")[1],
#     knitr = citation("knitr")[1],
#     RefManageR = citation("RefManageR")[1],
#     rmarkdown = citation("rmarkdown")[1],
#     sessioninfo = citation("sessioninfo")[1],
#     testthat = citation("testthat")[1],
#     ODER = citation("ODER")[1]
# )
```

# Basics

## Install `ODER`

`R` is an open-source statistical environment which can be easily modified to enhance its functionality via packages. `r Biocpkg("ODER")` is a `R` package available via the [Bioconductor](http://bioconductor.org) repository for packages. `R` can be installed on any operating system from [CRAN](https://cran.r-project.org/) after which you can install `r Biocpkg("ODER")` by using the following commands in your `R` session:

```{r "install", eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

BiocManager::install("ODER")

## Check that you have a valid Bioconductor installation
BiocManager::valid()
```

## Required knowledge

The expected input of `r Biocpkg("ODER")` is coverage in the form of BigWig files.

`r Biocpkg("ODER")` is based on many other packages and in particular in those that have implemented the infrastructure needed for dealing with RNA-seq data. The `r Biocpkg("GenomicRanges")` package is heavily used in `r Biocpkg("ODER")` while other packages like `r Biocpkg("SummarizedExperiment")` and `r Biocpkg("GenomeInfoDb")` also being featured so previous experience with these packages will help in the comprehension and use of `r Biocpkg("ODER")`.

If you are asking yourself the question "Where do I start using Bioconductor?" you might be interested in [this blog post](http://lcolladotor.github.io/2014/10/16/startbioc/#.VkOKbq6rRuU). If you find the structure of a `r Biocpkg("SummarizedExperiment")` unclear, you might consider checking out [this manual](http://master.bioconductor.org/help/course-materials/2019/BSS2019/04_Practical_CoreApproachesInBioconductor.html).



## Asking for help

As package developers, we try to explain clearly how to use our packages and in which order to use the functions. But `R` and `Bioconductor` have a steep learning curve so it is critical to learn where to ask for help. The blog post quoted above mentions some but we would like to highlight the [Bioconductor support site](https://support.bioconductor.org/) as the main resource for getting help: remember to use the `ODER` tag and check [the older posts](https://support.bioconductor.org/t/ODER/). Other alternatives are available such as creating GitHub issues and tweeting. However, please note that if you want to receive help you should adhere to the [posting guidelines](http://www.bioconductor.org/help/support/posting-guide/). It is particularly critical that you provide a small reproducible example and your session information so package developers can track down the source of the error.

## Citing `ODER`

We hope that `r Biocpkg("ODER")` will be useful for your research. Please use the following information to cite the package and the overall approach. Thank you!

```{r "citation"}
## Citation info
# citation("ODER")
```

# Quick start to using to `ODER`

ODER consists of 4 main functions, some of which consist of several smaller helper functions. These functions are

1. **ODER** - Returns the optimum definition of the expressed regions by finding the ideal MCC (Mean Coverage Cutoff) and MRG (Max Region Gap)
2. **annotatER** - Annotates the expressed regions with overlapping junctions and the nearest expressed genes
3. **refine_ers** - Uses the junctions to further refine the starts and the ends of the expressed regions
4. **get_count_matrix** - Scores the coverage of the expressed regions

```{r 'install_dev', eval = FALSE}
BiocManager::install("eolagbaju/ODER")
```
## Example

This is a basic example to show how you can use ODER, for reproducibility everything used in this vignette can either be found online or is contained in ODER. First, we need to download the data and information needed to run ODER:

```{r setup, eval = requireNamespace('ODER')}
#library("ODER")
library("magrittr")
# loading in RNA seq data to run ODER on
gtex_metadata <- recount::all_metadata("gtex")
gtex_metadata <- gtex_metadata %>%
    as.data.frame() %>%
    dplyr::filter(project == "SRP012682")
url <- recount::download_study(
    project = "SRP012682",
    type = "samples",
    download = FALSE
)
# .file_cache is an internal function to download a bigwig file from a link if the file has been downloaded recently, it will be retrieved from a cache
bw_path <- ODER:::.file_cache(url[1])
gtf_url <- "http://ftp.ensembl.org/pub/release-103/gtf/homo_sapiens/Homo_sapiens.GRCh38.103.chr.gtf.gz"
gtf_path <- ODER:::.file_cache(gtf_url)
```

To get the optimum set of ERs from a BigWig file we can use the ODER function, for stranded BigWigs there is the ODER_strand function:

```{r ODER}
# Getting the optimally defined ERs by finding the combination of Mean Coverage Cut-off and Max Region Gap that gives the smallest exon delta

# MCC - Mean Cutoff Coverage - this is the minimum read depth that a read needs to have to be considered expressed

# MRG - Max Region Gap - this is the maximum number of base pairs between reads that fall below the MCC before you would not include it as part of the expressed region

opt_ers <- ODER(
    bw_paths = bw_path, auc_raw = gtex_metadata[["auc"]][1], 
    auc_target = 40e6 * 100, chrs = c("chr21", "chr22"),
    genome = "hg38", mccs = c(2, 4, 6, 8, 10), mrgs = c(10, 20, 30),
    gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE,
    exons_no_overlap = NULL, bw_chr = "chr"
)

# for stranded bigwig files:

# bw_pos <- ODER:::.file_cache(url[58])
# bw_neg <- ODER:::.file_cache(url[84])
# opt_strand_ers <- ODER_strand(
#     bw_pos = bw_plus, bw_neg = bw_minus,
#     auc_raw_pos = gtex_metadata[["auc"]][58], auc_raw_neg = gtex_metadata[["auc"]][84],
#     auc_target = 40e6 * 100, chrs = c("chr21", "chr22"),
#     genome = "hg38", mccs = c(2, 4, 6, 8, 10), mrgs = c(10, 20, 30), 
#     gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = FALSE, exons_no_overlap = NULL, bw_chr = "chr"
# )

opt_ers
# opt_strand_ers
```

Once we have the opt_ers, we can generate a plot to see how the various MCCs and MRGs would look. The median exon delta represents the overall accuracy of all ER definitions, whereas the number of ERs with exon delta equal to 0 indicates the extent to which ER definitions precisely match overlapping exon boundaries.

```{r plot_example}
# visualise the spread of mccs and mrgs
plot_ers(opt_ers[["deltas"]], opt_ers[["opt_mcc_mrg"]])
```

To find the overlapping junctions and find the nearest expressed genes we can use annotatERs. The junctions used should be the same tissue type as the ERs from the BigWig passed into ODER, in this case we are looking at lung tissue data.

```{r annotatER_example}


# annotating the optimally defined ers with overlapping junctions

annot_ers <- annotatERs(
    opt_ers = opt_ers[["opt_ers"]], junc_data = lung_junc_21_22,
    gtf_path = gtf_path, chrs_to_keep = c("21", "22"), ensembl = TRUE
)

# To check the types of tissue you can filter for:
# print(tissue_options)

annot_ers <- add_expressed_genes(tissue = "lung", gtf_path = gtf_path, annot_ers = annot_ers)
```

We can use refine_ers to modify the starts and ends of the expressed regions by using refine_ers on the annotated regions.

```{r refineER_example}
# modify the starts and ends of the ERs using the junction data

refined_ers <- refine_ERs(annot_ers)

refined_ers
```

Generate an ER count matrix with get_count_matrix, if cols is left blank the function will auto-generate colData for the Ranged Summarized Experiment output.


```{r get_count_matrix_example}
# Generate a count matrix for the annotated ERs

run <- gtex_metadata[["run"]][[1]]
col_info <- as.data.frame(run)

er_count_matrix <- get_count_matrix(bw_paths = bw_path, annot_ers = annot_ers, cols = col_info)

er_count_matrix
```

# Comprehensive usage guide

In this section, we will run through the smaller functions that make up each of the big wrapper functions, ODER and annotatER, in detail. This can be helpful for users that want to understand or modify the intermediates of the `ODER` pipeline or are only interested in executing a specific step. If you want to follow along and run this code in your R session, make sure you have followed the instructions in the section [setup](#setup).

## Getting the coverage and Expressed Regions (ODER)

First we need to load in the coverage of the RNA seq data from a BigWig file using `get_coverage`, the output of this will be a `GRanges` object which we will generate all the possible ERs from the various MCCs and MRGs that you want to test by passing the `GRanges` into `get_ers`.

```{r ERs}

# getting the mean coverage of the expressed regions
coverage <- get_coverage(
    bw_paths = bw_path,
    auc_raw = gtex_metadata[["auc"]][1],
    auc_target = 40e6 * 100, # target 40 million coverage with 100 bp length reads
    chrs = c("chr21", "chr22")
) # defaults to chr1-22, chrX, chrY, chrM if chrs = ""

ers <- get_ers(coverage = coverage, mccs = c(2, 4, 6, 8, 10), mrgs = c(10, 20, 30))

ers
```

## Gold-Standard/Well Defined Exons (ODER)

To find the ideal MCC and MRG we need Gold-Standard/Well Defined Exons to compare it to and we get this by passing a gtf file into `get_exons`. By default the function will filter the gtf file to return non-overlapping exons but there is the option to filter for:
1. 3' UTR
2. 5' UTR
3. Internal
4. lncRNA
5. ncRN
6. pseudogene

```{r non_overlapping_exons}

exons_no_overlap <- get_exons(gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE)
# threeprime <- get_exons(gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE, biotype = "Three Prime")
# fiveprime <- get_exons(gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE, biotype = "Five Prime")
# internal <- get_exons(gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE, biotype = "Internal")
# lncrna <- get_exons(gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE, biotype = "lncRNA")
# ncrna <- get_exons(gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE, biotype = "ncRNA")
# pseudogene <- get_exons(gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE, biotype = "Pseudogene")
```
## Exon deltas (ODER)

To determine the best combination of MCC and MRG, we see which ER has the smallest absolute difference between the ER definition and the corresponding exon boundaries (exon delta). To get the exon deltas for the various ERs, we pass the ERs and the gold-standard exons into `get_ers_delta`.

```{r get_er_deltas}
# get the ers_delta
ers_delta <- get_ers_delta(ers = ers, opt_exons = exons_no_overlap)
ers_delta
# if you have your own delta function you can enter it as an argument i.e.
# delta_fun <- your_delta_function
```

## Optimum ERs (ODER)

Once we have the ers_delta we can get the optimum ERs by seeing which one has the combination of the smallest median exon delta (represents the overall accuracy of all ER definitions) and the least number of ERs with exon delta equal to 0 (indicates the extent to which ER definitions precisely match overlapping exon boundaries).

Passing our ERs and the ERs delta into `get_opt_ers` will give us the optimum ERs, the ideal MCC and MRG and the various deltas. 

```{r get_opt_ers}
# get the opt_ers
opt_ers <- get_opt_ers(ers = ers, ers_delta = ers_delta)
```

## Select the junctions (annotatER)

Once we have the opt_ers, we want to further improve them by finding overlapping junctions. `ODER` contains a small extract of lung junctions from GTEx which is used below. The junctions used in `get_junctions` should be from the same tissues as your ERs. 

```{r get_junctions}
junctions <- lung_junc_21_22
GenomeInfoDb::seqlevelsStyle(junctions) <- "NCBI"

ann_opt_ers <- get_junctions(opt_ers = opt_ers[["opt_ers"]], junc_data = junctions, gtf_path = gtf_path)
```

## Generate a Genomic State (annotatER)

We then convert a gtf file or a Txdb into a genomic state so that we can compare it with our expressed regions and use it as a reference point for the annotation.

```{r gen_gstate, echo=FALSE}

genomic_state <- generate_genomic_state(
    gtf = gtf_path,
    chrs_to_keep = c("21", "22"),
    ensembl = TRUE,
)
```

## Using the genomic state to annotate the ERs (annotatER)

Once we have our genomic state, we can use it to annotate each of the expressed regions as either an exon, intron or intergenic.

```{r annotateRegions, echo=FALSE}

annot_ers <- derfinder::annotateRegions(
    regions = ann_opt_ers, genomicState = genomic_state$fullGenome,
    maxgap = -1L, minoverlap = 1L
)
annot_table <- ODER:::annotate_table(annot_ers$countTable)
GenomicRanges::mcols(ann_opt_ers)$annotation <- annot_table[["region_annot"]]
GenomicRanges::mcols(ann_opt_ers)$og_index <- annot_table[["ER_index"]]

ann_opt_ers
```

## Refining the ERs (annotatER)

Once we have the ERs annotated and the overlapping junctions we are able to use those junctions to get a better definition of the ERs boundaries. As we are looking to discover novel exons, we filter for ERs that were annotated as intronic or intergenic and because we want well defined boundaries we only look at ERs that overlap with a maximum of two junctions and if it is two junctions, that those junctions themselves do not overlap.


```{r refine_ERs, echo=FALSE}

annot_ers <- annot_ers[S4Vectors::mcols(annot_ers)[["annotation"]] %in% c("intron", "intergenic")]
annot_ers <- annot_ers[lengths(S4Vectors::mcols(annot_ers)[["grl"]]) == 2 |
    lengths(S4Vectors::mcols(annot_ers)[["grl"]]) == 1]



ref_results <- ODER:::modify_ers(annot_ers)

partially_refined_ers <- ref_results[[1]]

changes <- ref_results[[2]]

fully_refined_ers <- partially_refined_ers[changes]
```


# Reproducibility


This package was developed using `r BiocStyle::Biocpkg("biocthis")`.


Code for creating the vignette

```{r createVignette, eval=FALSE}
## Create the vignette
library("rmarkdown")
system.time(render("ODER.Rmd", "BiocStyle::html_document"))

## Extract the R code
library("knitr")
knit("ODER.Rmd", tangle = TRUE)
```

Date the vignette was generated.

```{r reproduce1, echo=FALSE}
## Date the vignette was generated
Sys.time()
```

Wallclock time spent generating the vignette.

```{r reproduce2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits = 3)
```

`R` session information.

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```



# Bibliography


```{r vignetteBiblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
# PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```
