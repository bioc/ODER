---
title: "ODER workflow"
author: 
  - name: Emmanuel Olagbaju
    affiliation:
    - UCL
    email: e.olagbaju@ucl.ac.uk
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r doc_date()`"
package: "`r pkg_ver('ODER')`"
vignette: >
  %\VignetteIndexEntry{Introduction to ODER}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
```


```{r vignetteSetup, echo=FALSE, message=FALSE, warning = FALSE}
## Track time spent on making the vignette
startTime <- Sys.time()

## Bib setup
library("RefManageR")

# ## Write bibliography information
# bib <- c(
#     R = citation(),
#     BiocStyle = citation("BiocStyle")[1],
#     knitr = citation("knitr")[1],
#     RefManageR = citation("RefManageR")[1],
#     rmarkdown = citation("rmarkdown")[1],
#     sessioninfo = citation("sessioninfo")[1],
#     testthat = citation("testthat")[1],
#     ODER = citation("ODER")[1]
# )
```

# Basics

## Install `ODER`

`R` is an open-source statistical environment which can be easily modified to enhance its functionality via packages. `r Biocpkg("ODER")` is a `R` package available via the [Bioconductor](http://bioconductor.org) repository for packages. `R` can be installed on any operating system from [CRAN](https://cran.r-project.org/) after which you can install `r Biocpkg("ODER")` by using the following commands in your `R` session:

```{r "install", eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

BiocManager::install("ODER")

## Check that you have a valid Bioconductor installation
BiocManager::valid()
```

## Required knowledge

The expected input of `r Biocpkg("ODER")` is coverage in the form of BigWig files.

`r Biocpkg("ODER")` is based on many other packages and in particular in those that have implemented the infrastructure needed for dealing with RNA-seq data. The `r Biocpkg("GenomicRanges")` package is heavily used in `r Biocpkg("ODER")` while other packages like `r Biocpkg("SummarizedExperiment")` and `r Biocpkg("GenomeInfoDb")` also being featured so previous experience with these packages will help in the comprehension and use of `r Biocpkg("ODER")`.

If you are asking yourself the question "Where do I start using Bioconductor?" you might be interested in [this blog post](http://lcolladotor.github.io/2014/10/16/startbioc/#.VkOKbq6rRuU). If you find the structure of a `r Biocpkg("SummarizedExperiment")` unclear, you might consider checking out [this manual](http://master.bioconductor.org/help/course-materials/2019/BSS2019/04_Practical_CoreApproachesInBioconductor.html).



## Asking for help

As package developers, we try to explain clearly how to use our packages and in which order to use the functions. But `R` and `Bioconductor` have a steep learning curve so it is critical to learn where to ask for help. The blog post quoted above mentions some but we would like to highlight the [Bioconductor support site](https://support.bioconductor.org/) as the main resource for getting help: remember to use the `ODER` tag and check [the older posts](https://support.bioconductor.org/t/ODER/). Other alternatives are available such as creating GitHub issues and tweeting. However, please note that if you want to receive help you should adhere to the [posting guidelines](http://www.bioconductor.org/help/support/posting-guide/). It is particularly critical that you provide a small reproducible example and your session information so package developers can track down the source of the error.

## Citing `ODER`

We hope that `r Biocpkg("ODER")` will be useful for your research. Please use the following information to cite the package and the overall approach. Thank you!

```{r "citation"}
## Citation info
# citation("ODER")
```

# Quick start to using to `ODER`

ODER consists of 4 main functions, some of which consist of several smaller helper functions. These functions are

1. **ODER** - Returns the optimum definition of the expressed regions by finding the ideal MCC (Mean Coverage Cutoff) and MRG (Max Region Gap)
2. **annotatER** - Annotates the expressed regions with overlapping junctions and the nearest expressed genes
3. **refine_ers** - Uses the junctions to further refine the starts and the ends of the expressed regions
4. **get_count_matrix** - Scores the coverage of the expressed regions

```{r 'install_dev', eval = FALSE}
BiocManager::install("eolagbaju/ODER")
```
## Example

This is a basic example to show how you can use ODER, for reproducibility everything used in this vignette can either be found online or is contained in ODER. First, we need to download the data and information needed to run ODER:

```{r load_data, eval = requireNamespace('ODER')}
library("ODER")
library("magrittr")
# loading in RNA seq data to run ODER on
gtex_metadata <- recount::all_metadata("gtex")
gtex_metadata <- gtex_metadata %>%
    as.data.frame() %>%
    dplyr::filter(project == "SRP012682")
url <- recount::download_study(
    project = "SRP012682",
    type = "samples",
    download = FALSE
)
# .file_cache is an internal function to download a bigwig file from a link if the file has been downloaded recently, it will be retrieved from a cache
bw_path <- .file_cache(url[1])
gtf_url <- "http://ftp.ensembl.org/pub/release-103/gtf/homo_sapiens/Homo_sapiens.GRCh38.103.chr.gtf.gz"
gtf_path <- .file_cache(gtf_url)

gtf_gr <- rtracklayer::import(gtf_path)
```

To get the optimum set of ERs from a BigWig file we can use the ODER function, for stranded BigWigs there is the ODER_strand function:

```{r ODER}
# Getting the optimally defined ERs by finding the combination of Mean Coverage Cut-off and Max Region Gap that gives the smallest exon delta

# MCC - Mean Cutoff Coverage - this is the minimum read depth that a read needs to have to be considered expressed

# MRG - Max Region Gap - this is the maximum number of base pairs between reads that fall below the MCC before you would not include it as part of the expressed region

opt_ers <- ODER(
    bw_paths = bw_path, auc_raw = gtex_metadata[["auc"]][1],
    auc_target = 40e6 * 100, chrs = c("chr21"),
    genome = "hg38", mccs = c(2, 4, 6, 8, 10), mrgs = c(10, 20, 30),
    gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = TRUE,
    exons_no_overlap = NULL, bw_chr = "chr"
)

# for stranded bigwig files:

# bw_pos <- ODER:::.file_cache(url[58])
# bw_neg <- ODER:::.file_cache(url[84])
# opt_strand_ers <- ODER_strand(
#     bw_pos = bw_plus, bw_neg = bw_minus,
#     auc_raw_pos = gtex_metadata[["auc"]][58], auc_raw_neg = gtex_metadata[["auc"]][84],
#     auc_target = 40e6 * 100, chrs = c("chr21", "chr22"),
#     genome = "hg38", mccs = c(2, 4, 6, 8, 10), mrgs = c(10, 20, 30),
#     gtf = gtf_path, ucsc_chr = TRUE, ignore.strand = FALSE, exons_no_overlap = NULL, bw_chr = "chr"
# )

opt_ers
# opt_strand_ers
```

Once we have the opt_ers, we can generate a plot to see how the various MCCs and MRGs would look. The median exon delta represents the overall accuracy of all ER definitions, whereas the number of ERs with exon delta equal to 0 indicates the extent to which ER definitions precisely match overlapping exon boundaries.

The median exon delta represents the overall accuracy of all ER definitions, whereas the number of ERs with exon delta equal to 0 indicates the extent to which ER definitions precisely match overlapping exon boundaries.

```{r plot_example}
# visualise the spread of mccs and mrgs
plot_ers(opt_ers[["deltas"]], opt_ers[["opt_mcc_mrg"]])
```

To find the overlapping junctions and find the nearest expressed genes we can use annotatERs. The junctions used should be the same tissue type as the ERs from the BigWig passed into ODER, in this case we are looking at lung tissue data.

```{r annotatER_example}


# annotating the optimally defined ers with overlapping junctions


chrs_to_keep <- c("21")
#### preparing the txdb object
# gtf_txdb <- GenomicFeatures::makeTxDbFromGFF(file = gtf_path, format = "gtf")
# gtf_txdb <- GenomeInfoDb::keepSeqlevels(gtf_txdb, chrs_to_keep)
hg38_chrominfo <- GenomeInfoDb::getChromInfoFromUCSC("hg38")
new_info <- hg38_chrominfo$size[match(
    chrs_to_keep, # GenomeInfoDb::seqlevels(gtf_txdb),
    GenomeInfoDb::mapSeqlevels(hg38_chrominfo$chrom, "Ensembl")
)]
names(new_info) <- chrs_to_keep
gtf_gr_tx <- GenomeInfoDb::keepSeqlevels(gtf_gr,
    chrs_to_keep,
    pruning.mode = "tidy"
)
GenomeInfoDb::seqlengths(gtf_gr_tx) <- new_info
GenomeInfoDb::seqlevelsStyle(gtf_gr_tx) <- "UCSC"
rtracklayer::genome(gtf_gr_tx) <- "hg38"

ucsc_txdb <- GenomicFeatures::makeTxDbFromGRanges(gtf_gr_tx)
genom_state <- derfinder::makeGenomicState(txdb = ucsc_txdb)
ens_txdb <- ucsc_txdb
GenomeInfoDb::seqlevelsStyle(ens_txdb) <- "Ensembl"
################### end of genomstate creation


annot_ers <- annotatERs(
    opt_ers = head(opt_ers[["opt_ers"]], 100), junc_data = lung_junc_21_22,
    gtf_path = gtf_path, gtf = gtf_gr, txdb = ens_txdb,
    genom_state = genom_state
)

# To check the types of tissue you can filter for:
# print(tissue_options)

annot_ers <- add_expressed_genes(tissue = "lung", gtf = gtf_gr, annot_ers = annot_ers)

annot_ers
```

We can use refine_ers to modify the starts and ends of the expressed regions by using refine_ers on the annotated regions.

```{r refineER_example}
# modify the starts and ends of the ERs using the junction data

refined_ers <- refine_ERs(annot_ers)

refined_ers
```

Generate an ER count matrix with get_count_matrix, if cols is left blank the function will auto-generate colData for the Ranged Summarized Experiment output.


```{r get_count_matrix_example}
# Generate a count matrix for the annotated ERs

run <- gtex_metadata[["run"]][[1]]
col_info <- as.data.frame(run)

megadepth::install_megadepth()

er_count_matrix <- get_count_matrix(bw_paths = bw_path, annot_ers = annot_ers, cols = col_info)

er_count_matrix
```

# Reproducibility


This package was developed using `r BiocStyle::Biocpkg("biocthis")`.


Code for creating the vignette

```{r createVignette, eval=FALSE}
## Create the vignette
library("rmarkdown")
system.time(render("ODER.Rmd", "BiocStyle::html_document"))

## Extract the R code
library("knitr")
knit("ODER.Rmd", tangle = TRUE)
```

Date the vignette was generated.

```{r reproduce1, echo=FALSE}
## Date the vignette was generated
Sys.time()
```

Wallclock time spent generating the vignette.

```{r reproduce2, echo=FALSE}
## Processing time in seconds
totalTime <- diff(c(startTime, Sys.time()))
round(totalTime, digits = 3)
```

`R` session information.

```{r reproduce3, echo=FALSE}
## Session info
library("sessioninfo")
options(width = 120)
session_info()
```



# Bibliography


```{r vignetteBiblio, results = "asis", echo = FALSE, warning = FALSE, message = FALSE}
## Print bibliography
# PrintBibliography(bib, .opts = list(hyperlink = "to.doc", style = "html"))
```
